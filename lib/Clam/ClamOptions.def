/*** Translation LLVM to Crab Parameters ***/

cl::opt<CrabBuilderPrecision>
CrabTrackLev("crab-track",
   cl::desc("Track abstraction level of the Crab Cfg"),
   cl::values
    (clEnumValN(CrabBuilderPrecision::NUM, "num", "Integer and Boolean registers only"),
     clEnumValN(CrabBuilderPrecision::ARR, "arr", "num + some memory contents via array abstraction"),
     clEnumValN(CrabBuilderPrecision::REF, "ref", "num + all memory contents")),
   cl::init(CrabBuilderPrecision::NUM));

cl::opt<bool>
CrabCFGSimplify("crab-cfg-simplify",
	 cl::desc("Simplify Crab CFG"), 
	 cl::init(false),
	 cl::Hidden);

cl::opt<bool>
CrabPrintCFG("crab-print-cfg",
	 cl::desc("Print Crab CFG"), 
	 cl::init(false));

/**
 * Translate singleton alias sets as scalar values.
 * This is specially useful for global variables.
 */
cl::opt<bool>
CrabEnableUniqueScalars("crab-singleton-aliases",
	 cl::desc("Treat singleton alias sets as scalar values"), 
	 cl::init(false));

/**
 * Since LLVM IR is in SSA form many of the havoc statements are
 * redundant since variables can be defined only once.
 */
cl::opt<bool>
CrabIncludeHavoc("crab-include-useless-havoc",
		 cl::desc("Include all havoc statements."), 
		 cl::init(true),
		 cl::Hidden);

cl::opt<bool>
CrabEnableBignums("crab-enable-bignums",
     cl::desc("Translate bignums (> 64), otherwise operations with big numbers are havoced."), 
     cl::init(false));

namespace clam {
bool XShadowMem;
}

cl::opt<bool, true>
CrabShadowMem("crab-use-shadow-mem",
    cl::desc("Use seadsa shadow.mem functions to translate memory operations to Crab"),
    cl::location(clam::XShadowMem), cl::init(false), llvm::cl::Hidden);

/*** Crab Analysis Options ***/

cl::opt<bool>
CrabPrintAns("crab-print-invariants", 
              cl::desc("Print Crab invariants"),
              cl::init(false));

cl::opt<bool>
CrabPrintSumm("crab-print-summaries", 
               cl::desc("Print Crab function summaries"),
               cl::init(false));

cl::opt<bool>
CrabStoreInvariants("crab-store-invariants", 
               cl::desc("Store invariants"),
               cl::init(true));

cl::opt<bool>
CrabStats("crab-stats", 
           cl::desc("Show Crab statistics and analysis results"),
           cl::init(false));

cl::opt<bool>
CrabBuildOnlyCFG("crab-only-cfg", 
           cl::desc("Build Crab CFG without running the analysis"),
           cl::init(false));

cl::opt<bool>
CrabPrintUnjustifiedAssumptions("crab-print-unjustified-assumptions", 
cl::desc("Print unjustified assumptions done by Crab (experimental: only integer overflow)"),
cl::init(false));

cl::opt<unsigned int>
CrabWideningDelay("crab-widening-delay", 
   cl::desc("Max number of fixpoint iterations until widening is applied"),
   cl::init(1));

cl::opt<unsigned int>
CrabNarrowingIters("crab-narrowing-iterations", 
                   cl::desc("Max number of narrowing iterations"),
                   cl::init(10));

cl::opt<unsigned int>
CrabWideningJumpSet("crab-widening-jump-set", 
                    cl::desc("Size of the jump set used for widening"),
                    cl::init(0));

struct CrabDomainParser : public cl::parser<CrabDomain::Type> {
  CrabDomainParser(cl::Option &O): cl::parser<CrabDomain::Type>(O) {}

  void addLiteralOption(StringRef Name, const unsigned &V, StringRef HelpStr) {
    CrabDomain::Type TV;
    bool found = false;
    for (auto t : CrabDomain::List) {
       if (t.value() == V) {
          TV = t;
	  found = true;
	  break;
       }
    }
    if (found) {
      OptionInfo X(Name, TV, HelpStr);
      Values.push_back(X);
      AddLiteralOption(Owner, Name);
    } else {
      // TODO: ERROR
    }
  }

  // parse - Return true on error.
  bool parse(cl::Option &O, StringRef ArgName, const std::string &ArgValue,
             CrabDomain::Type &Val) {
    bool found = false;
    for (auto t : CrabDomain::List) {
       if (t.name() == ArgValue) {
          Val = t;
	  found = true;
	  break;
       }
    }
    return !found;
  }
};

cl::opt<CrabDomain::Type, false, CrabDomainParser>
ClamDomain("crab-dom",
      cl::desc("Crab numerical abstract domain used to infer invariants"),
      cl::values 
      (clEnumValN(CrabDomain::INTERVALS, "int",
		   "Classical interval domain (default)"),
       clEnumValN(CrabDomain::TERMS_INTERVALS, "term-int",
		   "Intervals with uninterpreted functions."),       
       clEnumValN(CrabDomain::INTERVALS_CONGRUENCES, "ric",
		   "Reduced product of intervals with congruences"),
       clEnumValN(CrabDomain::DIS_INTERVALS, "dis-int",
		   "Disjunctive intervals based on Clousot's DisInt domain"),
       clEnumValN(CrabDomain::TERMS_DIS_INTERVALS, "term-dis-int",
		   "Disjunctive Intervals with uninterpreted functions."),
       clEnumValN(CrabDomain::BOXES, "boxes",
		   "Disjunctive intervals based on ldds"),
       clEnumValN(CrabDomain::ZONES_SPLIT_DBM, "zones",
		   "Zones domain with Sparse DBMs in Split Normal Form"),
       clEnumValN(CrabDomain::OCT, "oct", "Octagons domain"),
       clEnumValN(CrabDomain::PK, "pk", "Polyhedra domain"),
       clEnumValN(CrabDomain::TERMS_ZONES, "rtz",
		   "Reduced product of term-dis-int and zones."),
       clEnumValN(CrabDomain::WRAPPED_INTERVALS, "w-int",
		  "Wrapped interval domain")),
       cl::init(CrabDomain::INTERVALS));

cl::opt<bool>
CrabBackward("crab-backward", 
	     cl::desc("Perform an iterative forward/backward analysis.\n"
		      "It is only useful to prove assertions.\n"
		      "Only the intra-procedural version has been implemented."),
           cl::init(false));

// If domain is num
cl::opt<unsigned>
CrabRelationalThreshold("crab-relational-threshold", 
   cl::desc("Max number of live vars per block before switching "
	    "to a non-relational domain"),
   cl::init(10000),
   cl::Hidden);

cl::opt<bool>
CrabLive("crab-live", 
	 cl::desc("Run Crab with live ranges. "
		  "It can lose precision if relational domains"),
	 cl::init(false));

cl::opt<bool>
CrabInter("crab-inter",
           cl::desc("Crab Inter-procedural analysis"), 
           cl::init(false));

cl::opt<unsigned>
CrabInterMaxSummaries("crab-inter-max-summaries", 
	 cl::desc("Maximum number of summaries per function tracked by "
		  "the interprocedural analysis"),
	 cl::init(UINT_MAX));

cl::opt<heap_analysis_t>
CrabHeapAnalysis("crab-heap-analysis",
   cl::desc("Heap analysis used for memory disambiguation"),
   cl::values
    (clEnumValN(heap_analysis_t::NONE, "none",
                "Disable heap analysis"),
     clEnumValN(heap_analysis_t::CI_SEA_DSA, "ci-sea-dsa",
                "context-insensitive sea-dsa"),
     clEnumValN(heap_analysis_t::CS_SEA_DSA, "cs-sea-dsa",
                "context-sensitive sea-dsa")),
   cl::init(heap_analysis_t::CI_SEA_DSA));
    
cl::opt<bool>
CrabDsaDisambiguateUnknown("crab-dsa-disambiguate-unknown",
    cl::desc("Disambiguate unknown pointers (unsound)"), 
    cl::init(false),
    cl::Hidden);

cl::opt<bool>
CrabDsaDisambiguatePtrCast("crab-dsa-disambiguate-ptr-cast",
    cl::desc("Disambiguate pointers that have been casted from/to integers (unsound)"), 
    cl::init(false),
    cl::Hidden);

cl::opt<bool>
CrabDsaDisambiguateExternal("crab-dsa-disambiguate-external",
    cl::desc("Disambiguate pointers that have been passed to external functions (unsound)"), 
    cl::init(false),
    cl::Hidden);

// Prove assertions
cl::opt<CheckerKind>
CrabCheck("crab-check", 
	   cl::desc("Check user assertions"),
	   cl::values(
	       clEnumValN(CheckerKind::NOCHECKS  , "none"  , "None"),
	       clEnumValN(CheckerKind::ASSERTION , "assert", "User assertions")),
	   cl::init(CheckerKind::NOCHECKS));

cl::opt<unsigned int>
CrabCheckVerbose("crab-check-verbose", 
                 cl::desc("Print verbose information about checks"),
                 cl::init(0));

// Important to clam clients (e.g., SeaHorn):
// Shadow variables are variables that cannot be mapped back to a
// const Value*. These are created for instance for memory heaps.
cl::opt<bool>
CrabKeepShadows("crab-keep-shadows",
    cl::desc("Preserve shadow variables in invariants, summaries, and preconditions"), 
    cl::init(false),
    cl::Hidden);

/* Debugging/Logging/Sanity Checks options */

struct LogOpt {
  void operator=(const std::string &tag) const 
  { crab::CrabEnableLog(tag); } 
};

LogOpt loc;

static llvm::cl::opt<LogOpt, true, llvm::cl::parser<std::string>> 
LogClOption("crab-log",
             llvm::cl::desc("Enable specified log level"),
             llvm::cl::location(loc),
             llvm::cl::value_desc("string"),
             llvm::cl::ValueRequired, llvm::cl::ZeroOrMore);

struct VerboseOpt {
  void operator=(unsigned level) const 
  { crab::CrabEnableVerbosity(level); } 
};

VerboseOpt verbose;

static llvm::cl::opt<VerboseOpt, true, llvm::cl::parser<unsigned>> 
CrabVerbose("crab-verbose",
	    llvm::cl::desc("Enable verbose messages"),
	    llvm::cl::location(verbose),
	    llvm::cl::value_desc("uint"));


struct WarningOpt {
  void operator=(bool val) const 
  { crab::CrabEnableWarningMsg(val); } 
};

WarningOpt warning;

static llvm::cl::opt<WarningOpt, true, llvm::cl::parser<bool>> 
CrabEnableWarning("crab-enable-warnings",
	    llvm::cl::desc("Enable warning messages"),
	    llvm::cl::location(warning),
	    llvm::cl::value_desc("bool"));

struct SanityChecksOpt {
  void operator=(bool val) const 
  { crab::CrabEnableSanityChecks(val); } 
};

SanityChecksOpt sanity;

static llvm::cl::opt<SanityChecksOpt, true, llvm::cl::parser<bool>> 
CrabSanityChecks("crab-sanity-checks",
	    llvm::cl::desc("Enable sanity checks"),
	    llvm::cl::location(sanity),
	    llvm::cl::value_desc("bool"));
